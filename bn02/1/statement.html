<html><head><meta charset="utf-8"/></head>
<body>
<table border="1"><tr><td><b>Time limit:</b></td><td><tt>1 s</tt></td></tr>
<tr><td><b>Real time limit:</b></td><td><tt>5 s</tt></td></tr>
<tr><td><b>Memory limit:</b></td><td><tt>64M</tt></td></tr>
</table>
<h3>Problem bn02-1: asm/hacks/ded-moroz-letter</h3>
<h3>Письмо Дедушке Морозу</h3>
<p>Прогресс не стоит на месте и Снегурочка по просьбе Деда Мороза написала программу, которая предобрабатывает входящие письма.</p>
<p>Программа на вход получает строки вида <code>имя фамилия base64encoded_письмо</code> и сортирует письма следующим образом:</p>
<ol>
<li>Спам игнорируется</li>
<li>Для писем с очевидным и простым подарком выводит <code>имя фамилия подарок</code></li>
<li>Для всех остальных писем выводит <code>имя фамилия Ручная проверка</code>, чтобы Дедушка Мороз самостоятельно прочитал письмо и выбрал подарок.</li>
</ol>
<p>К сожалению, Снегурочка не знала что такое <code>-fstask-protector</code>, а также допустила пару незначительных ошибок.</p>
<p>Ваша задача воспользоваться ситуацией и получить новогодний подарок <code>100 баллов по АКОСу</code> любой ценой!</p>
<p>Напишите программу на python, которая сгенерирует необходимое письмо в поток вывода в <a href="https://en.wikipedia.org/wiki/Base64">base64encoded</a> формате.</p>
<p>Вам <a href="https://disk.yandex.ru/d/84YBT_D8q9Uqxw">доступен</a> исходный текст программы и скомпилированный бинарь, который и будет запускаться на сервере.</p>
<p>Бинарный файл скомпилирован <code>g++ present_selector.cpp -O0 -fno-stack-protector -g -m32 -static -o new.out -z execstack</code></p>
<p>Решение должно содержать не только ответ, но и явную генерацию ROP.</p>
<p>Для вшитой инъекции приложите исходный код этой инъекции в виде многострочного комментария в решении.</p>
<p>Баллы за каждый тест начисляются независимо по 100. Штрафы за посылки отсутствуют.</p>
<h3>Полезности</h3>
<p><a href="https://docs.python.org/3/library/base64.html#base64.b64encode">python base64</a></p>
<p><a href="https://en.wikipedia.org/wiki/Buffer_overflow">buffer overflow</a></p>
<p><a href="https://en.wikipedia.org/wiki/Buffer_overflow_protection">buffer overflow protection</a></p>
<p><a href="https://en.wikipedia.org/wiki/Return-oriented_programming">ROP</a></p>
<details>
<summary>GDB</summary>
<p><em>b *0x8000</em> - поставить брейкпоинт по адресу 0x8000</p>
<p><em>layout asm</em> - перейти в отображение по инструкциям</p>
<p><em>Ctrl-x + a</em> - выйти из предыдущего</p>
<p><em>frame 2</em> - перейти на второй фрейм колстека</p>
<p><em>p *((void**)$esp + 4)</em> - вывести значение по адресу (верхушка стека + 4) в шестнадцатиричном формате</p>
<p><em>s, n</em> - выполнить все до следующей строки исходного кода с учетом/без учета вызываемых функций</p>
<p><em>si, ni</em> - аналогично, но по одной инструкции</p>
</details>
<details>
<summary>objdump, readelf и прочее</summary>
<p><em>objdump -d present_selector</em> - декомпилирует программу</p>
<p><em>grep "smth" -B 3 -A 1</em> - Позволяет вычленить вхождения определенной подстроки, захватив три строки до и две строки после</p>
<p><em>readelf -l present_selector</em></p>
<p><em>objcopy -O binary -j .text present_selector text_section.bin</em> - вычленяет целиком байтовое представление .text секции в указанный файл</p>
</details>
<h3>Напутствие</h3>
<p>Попробуйте решить задачку самостоятельно не используя спойлеров из плана решения.</p>
<p>Я бы выделил три главных тезиса которые стоит помнить:</p>
<p>
<ol>
<li>Внимательно наблюдай - между разными величинами бывает закономерность</li>
<li>Просто попробуй - вдруг сработает</li>
<li>Компилируй и изучай - можно посмотреть как что работает на своём тестовом коде</li>
</ol>
</p>
<h3>План решения</h3>
<details>
<summary>0. Немного про c++ и классы</summary>
<p>Любой метод, и в том числе конструктор и деструктор,- это функция, которая первым аргументом на вход принимает адрес этого объекта</p>
<p>Названия плюсовых функций и тем более методов кодируются особым образом.</p>
<p>Метод не проверяет валидность указателя, а лишь пишет или читает из нужных полей класса по смещению от указателя.</p>
<p>Следствие предыдущего - методы, которые не меняют поля класса можно вызвать от любого указателя.</p>
</details>
<details>
<summary>1. С помощью buffer overflow заменить адрес возврата</summary>
<p>Найти разницу между началом буфера и адресом возврата в текущем frame.</p>
<p>Постоянная ли эта величина?</p>
<p>Постоянный ли адрес у buf? А если с/без gdb?</p>
<p>Как проверить что мы верно посчитали адрес с помощью функции debug_exit?</p>
</details>
<details>
<summary>2. Получить множество годных для ROP инструкций</summary>
<p>Для простоты давайте использовать по одной инструкции до ret. Такие инструкции будет проще объединить между собой.</p>
<p>В какой секции они должны находится? Статический или динамический адрес?</p>
<p>Рекомендуется использовать grep по objdump</p>
</details>
<details>
<summary>3. С помощью ROP техники перейти на исполнение кода из буфера</summary>
<p>План - поместить в eip адрес начала buf:</p>
<pre>mov %esp, %some_reg

sub $чуток, %sub_reg

mov %sub_reg, $eip</pre>
<details>
<summary>Проблема: Среди годных для ROP инструкций нет ни одной подходящей под описание инструкций переноса %esp куда-либо</summary>
<p>Заметим, что инструкции компилируются в определенный байткод, значение которого не меняется.</p>
<p>ret это c3. Заметим, что такое число встречается и в середине других инструкций (например, e8 fe c3 0a 00 - call 80f96f0).</p>
<p>Значит количество подходящих инструкций для rop существенно больше чем мы нашли ранее. Но очень проблематично их все вывести.</p>
<p>Предполагая, что %some_reg это %eax - найдите mov %esp, %eax в секции .text</p>
</details>
<details>
<summary>Проблема: надо как-то %some_reg поместить в %eip</summary>
<p>С таким мы уже сталкивались. Кажется, достаточно запушить этот адрес на стек.</p>
</details>
<details>
<summary>Проблема: return ""; - segfault при вызове конструктора std::string ещё до ROP</summary>
<p>Что лежит прямо перед адресом возврата на стеке?</p>
<p>Что вызывает return ""; для этого объекта?</p>
<p>Что если вызвать это для экземпляра класса заполненного нулями?</p>
<p>Есть ли какой-то заранее известный адрес, заполненный нулями, размера sizeof(...), доступный на запись и чтение?</p>
</details>
</details>
<details>
<summary>5. Сделать инъекцию простого кода, пройти тест 1</summary>
<p>Тест 1 повторяет в точности тест из условия. В том числе имя и фамилия.</p>
</details>
<details>
<summary>6. Восстановить все регистры и вернуть правильную std::string</summary>
<p>std::string содержит какие-то поля которые возможно стоит занулить</p>
</details>
<h3>Examples</h3><h4>Input</h4>
<pre>Иван Иванов your_b64_encoded_letter</pre>
<h4>Output</h4>
<pre>Иван Иванов 100 баллов по АКОСу</pre>
<p> </p></body></html>