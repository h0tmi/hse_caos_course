<html><head><meta charset="utf-8"/></head>
<body>
<table border="1"><tr><td><b>Time limit:</b></td><td><tt>2 s</tt></td></tr>
<tr><td><b>Real time limit:</b></td><td><tt>5 s</tt></td></tr>
<tr><td><b>Memory limit:</b></td><td><tt>512M</tt></td></tr>
</table>
<h3>Problem sm06-4: c/mem/gc</h3>
<p>Напишите mark-and-sweep garbage collector (сборщик мусора), который находит динамически выделенные
            области памяти, которые более не достижимы, и освобождает их.</p>
<p>Как известно, большой сложностью при программировании на языках с явным управлением памятью
            является необходимость явно управлять памятью. Она приводит к таким проблемам,
            как утечки памяти (memory leaks),
            использование ранее освобождённой динамической памяти (use after free), повторное освобождение
            области памяти (double free) и другие способы испортить кучу (heap corruption). Хотелось бы,
            чтобы компьютер как-нибудь сам следил, какие области динамической памяти нам ещё нужны,
            а какие не нужны и могут быть освобождены.</p>
<p>Будем называть <em>аллокацией</em> область памяти, полученную в результате вызова <code>malloc</code>.
            Для каждой аллокации будем хранить такие сведения:</p>
<pre>typedef void (*finalizer_t)(void *ptr, size_t size);

struct allocation {
    void *ptr; // указатель на область памяти
    size_t size; // размер
    finalizer_t finalizer; // функция, которую следует вызвать перед free
    bool alive; // достижимость
};</pre>
<p>Указатель <code>ptr</code> считается указателем на аллокацию <code>A</code>, если содержит адрес
            любого байта внутри аллокации или байта сразу после аллокации:</p>
<pre>bool points_to(void *ptr, struct allocation *A) {
    uintptr_t uptr = (uintptr_t)ptr, aptr = (uintptr_t)A-&gt;ptr;
    return (uptr &gt;= aptr) &amp;&amp; (uptr - aptr &lt;= A-&gt;size);
}</pre>
<p>Аллокация считается достижимой, если указатель на неё есть в стеке либо в другой достижимой аллокации.
            Учитываются только правильно выровненные указатели (хранящиеся в памяти по адресам, кратным
            <code>alignof(void *)</code>).</p>
<p>Сдаваемый файл должен содержать реализации функций <code>gc_init</code>, <code>gc_malloc</code> и 
            <code>gc_collect_impl</code>, <a href="https://caos2023.myltsev.ru/cgi-bin/new-client?SID=eab2c46dc54d6c42&amp;prob_id=33&amp;action=194&amp;file=gc.h">объявленных</a> таким образом:</p>
<pre>void gc_init(char **argv);
void *gc_malloc(size_t size, finalizer_t finalizer);
void gc_collect_impl(uintptr_t stack_top);</pre>
<p>Программа, которая использует ваш сборщик мусора, обязана в функции main вызвать <code>gc_init</code>
             с параметром argv. Известно, что массив аргументов командной строки лежит внизу стека
             (по адресу, большему, чем адреса любых автоматических переменных),
             так что argv можно использовать как указатель на дно стека.</p>
<p>Функция <code>gc_malloc</code> вызывает <code>malloc</code> с переданным ей параметром <code>size</code>
             и в случае успешной аллокации (когда malloc вернул не NULL) записывает сведения об этой аллокации
             в свои структуры данных (которые вам предстоит определить).</p>
<p>Функция <code>gc_collect_impl</code> работает следующим образом.</p>
<ul>
<li>Помечает все известные ей аллокации как недостижимые.</li>
<li>Проходит по стеку от <code>stack_top</code> (указатель на верхушку стека)
                 до <code>stack_bottom</code> (указатель на дно стека) и пытается интерпретировать каждые
                 <code>sizeof(void *)</code> байт из стека как указатель. Если это указатель на некоторую
                 известную аллокацию A, то она помечается как достижимая.</li>
<li>Таким же образом проходит по всем достижимым аллокациям, находя в них указатели
                 и помечая достижимые аллокации.</li>
<li>Для каждой недостижимой аллокации <code>A</code> вызывает <code>A.finalizer(A.ptr, A.size)</code>
                 (если finalizer не NULL) и <code>free(A.ptr)</code>, а затем удаляет сведения об аллокации. Недостижимые аллокации можно удалять в любом порядке.</li>
</ul>
<p><code>gc_collect_impl</code> будет вызываться с помощью ассемблерной обёртки
             <a href="https://caos2023.myltsev.ru/cgi-bin/new-client?SID=eab2c46dc54d6c42&amp;prob_id=33&amp;action=194&amp;file=wrapper.S"><code>gc_collect</code></a>,
             которая сохраняет в стек значения callee-saved регистров и передаёт корректный
             указатель на верхушку стека <code>stack_top</code>. Таким образом, искать указатели в регистрах не придётся.</p>
<p>Программе запрещено вызывать realloc и free для тех областей памяти, которые были получены
             с помощью <code>gc_malloc</code>. Программа может хранить указатели на такие области памяти
             в глобальных и статических переменных (т. е. не в стеке), но сборщик мусора не будет учитывать
             такие указатели (не будет считать достижимой область памяти, указатель на которую есть
             только в глобальной переменной).</p>
<p> </p></body></html>