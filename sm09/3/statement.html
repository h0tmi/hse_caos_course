<html><head><meta charset="utf-8"/></head>
<body>
<table border="1"><tr><td><b>Time limit:</b></td><td><tt>1 s</tt></td></tr>
<tr><td><b>Real time limit:</b></td><td><tt>5 s</tt></td></tr>
<tr><td><b>Memory limit:</b></td><td><tt>64M</tt></td></tr>
</table>
<h3>Problem sm09-3: unix/files/binary-tree-2</h3>
<p>
В аргументах командной строки задается имя входного бинарного файла произвольного доступа. Бинарный файл рассматривается как массив структур:</p>
<p><tt><pre>struct Node
{
    int32_t key;
    int32_t left_idx;
    int32_t right_idx;
};</pre></tt></p>
<p>Структура описывает вершину бинарного дерева поиска, где <tt>key</tt> – ключ поиска,
   а значения <tt>left_idx</tt> и <tt>right_idx</tt> – индексы в массиве соответственно левой и правой вершины.
   Корень дерева находится в элементе массива с индексом 0. Признаком отсутствия соответствующего поддерева в вершине является индекс, равный 0.</p>
<p>Числа в файле хранятся в естественном для x86 представлении (little-endian).</p>
<p>На стандартный поток вывода напечатайте ключи, размещенные в данном дереве, в порядке убывания.</p>
<p>Считывать содержимое всего файла в память целиком (хранить полное дерево в памяти) запрещается.
   Для чтения содержимого файла необходимо пользоваться низкоуровневым вводом-выводом (open/read/etc).
   Корректная работа на big-endian архитектуре не требуется. Не используйте низкоуровневые манипуляции с памятью (union, приведение типов указателей).
   Не используйте библиотечные функции преобразования.</p>
<p>Для вывода ключей можно использовать высокоуровневые потоки (stdout).</p>
<p>Не забывайте выводить '\n' в конце вывода.</p>
<p>В программе должна быть реализована проверка корректности чтения из файла. Минимизируйте число системных вызовов, необходимых для чтения одной записи из файла.</p>
<p>Например для этого <a href="https://caos2023.myltsev.ru/cgi-bin/new-client?SID=a5bd5a9bcf7844e3&amp;prob_id=63&amp;action=194&amp;file=001.dat">файла</a> надо вывести <code>9 8 7 6 5 4 3 2 1</code></p>
<p> </p></body></html>